<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>

    <title>Optimised CPU Ray Marching</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/blog/assets/built/screen.css?v=2ad5fe5275" />

    <meta name="description" content="This article explains how we optimised the ray marching algorithm in Sector&#x27;s Edge that handles collision detection for tens of thousands of particles." />
    <link rel="icon" href="https://vercidium.com/blog/content/images/size/w256h256/2021/08/vlogo.png" type="image/png" />
    <link rel="canonical" href="https://vercidium.com/blog/optimised-voxel-raymarching/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="https://vercidium.com/blog/optimised-voxel-raymarching/amp/" />
    
    <meta property="og:site_name" content="Vercidium Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Optimised CPU Ray Marching" />
    <meta property="og:description" content="This article explains how we optimised our ray marching algorithm that handles collision detection for tens of thousands of particles." />
    <meta property="og:url" content="https://vercidium.com/blog/optimised-voxel-raymarching/" />
    <meta property="og:image" content="https://vercidium.com/blog/content/images/2020/01/raymarching.jpg" />
    <meta property="article:published_time" content="2020-01-18T03:12:22.000Z" />
    <meta property="article:modified_time" content="2020-01-18T03:34:07.000Z" />
    <meta property="article:tag" content="voxel" />
    <meta property="article:tag" content="optimisations" />
    <meta property="article:tag" content="raymarching" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Optimised CPU Ray Marching" />
    <meta name="twitter:description" content="This article explains how we optimised our ray marching algorithm that handles collision detection for tens of thousands of particles." />
    <meta name="twitter:url" content="https://vercidium.com/blog/optimised-voxel-raymarching/" />
    <meta name="twitter:image" content="https://vercidium.com/blog/content/images/2020/01/raymarching.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Mitchell Robinson" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="voxel, optimisations, raymarching" />
    <meta name="twitter:site" content="@Vercidium" />
    <meta property="og:image:width" content="1920" />
    <meta property="og:image:height" content="1080" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Vercidium Blog",
        "url": "https://vercidium.com/blog/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://vercidium.com/blog/content/images/2021/08/vlogo-1.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Mitchell Robinson",
        "url": "https://vercidium.com/blog/author/mitchell/",
        "sameAs": []
    },
    "headline": "Optimised CPU Ray Marching",
    "url": "https://vercidium.com/blog/optimised-voxel-raymarching/",
    "datePublished": "2020-01-18T03:12:22.000Z",
    "dateModified": "2020-01-18T03:34:07.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://vercidium.com/blog/content/images/2020/01/raymarching.jpg",
        "width": 1920,
        "height": 1080
    },
    "keywords": "voxel, optimisations, raymarching",
    "description": "This article explains how we optimised our ray marching algorithm that handles collision detection for tens of thousands of particles.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://vercidium.com/blog/"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.2" />
    <link rel="alternate" type="application/rss+xml" title="Vercidium Blog" href="https://vercidium.com/blog/rss/" />
    <script defer src="https://unpkg.com/@tryghost/portal@~2.2.0/umd/portal.min.js" data-ghost="https://vercidium.com/blog/" data-key="fee3be88284ec1c01392f8b2e8" data-api="https://vercidium.com/blog/ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="/blog/public/cards.min.js?v=2ad5fe5275"></script>
    <link rel="stylesheet" type="text/css" href="/blog/public/cards.min.css?v=2ad5fe5275">
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-139555584-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-139555584-1');
</script>

<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/components/prism-css.min.js"/>
<link rel="stylesheet" type="text/css" href="/prism-okaidia.css" />

<style>:root {--ghost-accent-color: #1081ef;}</style>

</head>
<body class="post-template tag-voxel-2 tag-optimisations tag-raymarching has-sans-body has-cover">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <nav class="gh-head-inner inner">

            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://vercidium.com/blog">
                        <img src="https://vercidium.com/blog/content/images/2021/08/vlogo-1.png" alt="Vercidium Blog" />
                </a>
                <a class="gh-burger" role="button">
                    <div class="gh-burger-box">
                        <div class="gh-burger-inner"></div>
                    </div>
                </a>
            </div>
            <div class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://vercidium.com/blog/">Home</a></li>
    <li class="nav-sectors-edge"><a href="https://sectorsedge.com/s/s2s9">Sector&#x27;s Edge</a></li>
    <li class="nav-twitter"><a href="https://twitter.com/vercidium">Twitter</a></li>
    <li class="nav-discord"><a href="https://sectorsedge.com/d/s2s9">Discord</a></li>
</ul>

            </div>
            <div class="gh-head-actions">
                <div class="gh-social">
                        <a class="gh-social-link gh-social-twitter" href="https://twitter.com/Vercidium" title="Twitter" target="_blank" rel="noopener"><svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M23.954 4.569c-.885.389-1.83.654-2.825.775 1.014-.611 1.794-1.574 2.163-2.723-.951.555-2.005.959-3.127 1.184-.896-.959-2.173-1.559-3.591-1.559-2.717 0-4.92 2.203-4.92 4.917 0 .39.045.765.127 1.124C7.691 8.094 4.066 6.13 1.64 3.161c-.427.722-.666 1.561-.666 2.475 0 1.71.87 3.213 2.188 4.096-.807-.026-1.566-.248-2.228-.616v.061c0 2.385 1.693 4.374 3.946 4.827-.413.111-.849.171-1.296.171-.314 0-.615-.03-.916-.086.631 1.953 2.445 3.377 4.604 3.417-1.68 1.319-3.809 2.105-6.102 2.105-.39 0-.779-.023-1.17-.067 2.189 1.394 4.768 2.209 7.557 2.209 9.054 0 13.999-7.496 13.999-13.986 0-.209 0-.42-.015-.63.961-.689 1.8-1.56 2.46-2.548l-.047-.02z"/></svg></a>
                </div>
                        <a class="gh-head-button" href="#/portal/signup" data-portal="signup">Subscribe</a>
            </div>
        </nav>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post tag-voxel-2 tag-optimisations tag-raymarching featured ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="/blog/tag/voxel-2/">voxel</a>
                </span>
                <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
        </div>

        <h1 class="article-title">Optimised CPU Ray Marching in a Voxel World</h1>

            <p class="article-excerpt">This article explains how we optimised our ray marching algorithm that handles collision detection for tens of thousands of particles.</p>

        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/blog/author/mitchell/" class="author-avatar author-profile-image"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="/blog/author/mitchell/">Mitchell Robinson</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2020-01-18">Jan 18, 2020</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 6 min read</span>
                </div>
            </div>

        </section>
        </div>

            <figure class="article-image">
                <img
                    srcset="/blog/content/images/size/w300/2020/01/raymarching.jpg 300w,
                            /blog/content/images/size/w600/2020/01/raymarching.jpg 600w,
                            /blog/content/images/size/w1000/2020/01/raymarching.jpg 1000w,
                            /blog/content/images/size/w2000/2020/01/raymarching.jpg 2000w"
                    sizes="(min-width: 1400px) 1400px, 92vw"
                    src="/blog/content/images/size/w2000/2020/01/raymarching.jpg"
                    alt="Optimised CPU Ray Marching in a Voxel World"
                />
            </figure>

    </header>

    <section class="gh-content gh-canvas">
        <p>This article explains how we optimised the ray marching algorithm in <a href="https://www.youtube.com/watch?v=qoKzhIouzsk">Sector's Edge</a> that handles collision detection for tens of thousands of particles.</p><p>The full source code for this article is available <a href="https://github.com/Vercidium/voxel-ray-marching">here on GitHub</a>.</p><h2 id="overview">Overview</h2><p>The voxel world is divided into groups of 32 x 32 x 32 blocks, each of which are managed by a separate <code>Chunk</code> class instance. This structure is especially useful for:</p><ul><li>Rendering optimisations, as chunks outside the current viewport can be skipped</li><li><a href="https://vercidium.com/blog/voxel-world-optimisations/">Fast mesh regeneration</a> when blocks in a chunk are changed</li><li>Memory optimisations, as chunks that contain no blocks are left uninitialised</li></ul><p>This voxel ray marching algorithm is based on <a href="http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf">A Fast Voxel Traversal Algorithm for Ray Tracing</a> by <em>John Amanatides</em> and <em>Andrew Woo</em> and has been optimised by keeping block lookups within the current working chunk. As this algorithm is quite long, we will analyse it in sections.</p><h2 id="map-structure">Map Structure</h2><p><code>Chunks</code> are stored in a three-dimensional array within the <code>Map</code> class, however <code>Blocks</code> are stored in a one-dimensional array in the <code>Chunk</code> for fast lookup:</p><!--kg-card-begin: markdown--><pre><code class="language-csharp">public class Map
{
    Chunk[,,] chunks;
}

public class Chunk
{
    const int CHUNK_SIZE = 32;
    const int CHUNK_SIZE_SQUARED = 1024;
    const int CHUNK_SIZE_CUBED = 32768;
    Block[] data = new Block[CHUNK_SIZE_CUBED];
}

public struct Block
{
    byte kind;  // e.g. empty, dirt, metal, etc.
}
</code></pre>
<!--kg-card-end: markdown--><p></p><p><code>Blocks</code> within the <code>Chunk</code> are accessed as follows:</p><!--kg-card-begin: markdown--><pre><code class="language-csharp">int access = j + i * CHUNK_SIZE + k * CHUNK_SIZE_SQUARED;
Block b = data[access];
</code></pre>
<!--kg-card-end: markdown--><p></p><p><em><em>For clarity, <code>i, j and k</code> refer to chunk-relative positions (range 0-31)</em></em><br><em><em>and <code>x, y and z</code> refer to </em>map-relative<em> positions (range 0-511)</em></em></p><h2 id="ray-marching">Ray Marching</h2><p>The problem with the original ray marching algorithm in Sector's Edge was that it worked with map-relative positions. This meant that every time the algorithm checked if a block existed at a specific position, it had to calculate which chunk the block belonged to and then convert the map-relative position to a chunk-relative position:</p><!--kg-card-begin: markdown--><pre><code class="language-csharp">const int SHIFT = 5;
const int MASK = 0x1f;
public Block GetBlock(int x, int y, int z)
{
    // Get the chunk the block belongs to
    var c = chunks[x &gt;&gt; SHIFT, y &gt;&gt; SHIFT, z &gt;&gt; SHIFT];

    if (c == null)
        return true;

    // Bitmask to get the chunk-relative position
    return c.data[(y &amp; MASK) +
                  (x &amp; MASK) * CHUNK_SIZE +
                  (z &amp; MASK) * CHUNK_SIZE_SQUARED];
}</code></pre>
<!--kg-card-end: markdown--><p></p><p>The new algorithm obtains a reference to the chunk at the beginning of the function and only updates it when the ray enters a new chunk. This chunk is referred to as the <code>current working chunk</code>.</p><p>The second optimisation was to add two exit checks at the beginning of the function that check if the ray starts outside the map, or if the ray begins and ends at the same map-relative position:</p><ul><li>Exit if the ray starts outside the map bounds as there are no blocks to collide with. There will never be a case where the ray starts outside the map and travels towards the centre of the map</li><li>Exit if the start and end position of the ray both lie on the same coordinate on the voxel grid. This check saves a lot of time for particles, as they are often at rest on the top of a block</li></ul><p>The <code>RayMarch(...)</code> function parameters are as follows:</p><ul><li><code>in Vector3 start</code> - the start position of the ray</li><li><code>Vector3 velocity</code> - the direction of the ray</li><li><code>in double max</code> - the maximum length that the ray can travel</li><li><code>ref bool hit</code> - set to true if the ray collides with a solid block</li><li><code>ref Axis axis</code> - set to either <code>Axis.X, Axis.Y or Axis.Z</code> depending on which block face the ray hit</li></ul><!--kg-card-begin: markdown--><pre><code class="language-csharp">public void RayMarch(in Vector3 start, Vector3 velocity, in double max, ref bool hit, ref Axis axis)
{
    // Convert the start position to integer voxel coordinates
    int x = (int)start.X;
    int y = (int)start.Y;
    int z = (int)start.Z;

    // If the start coordinate is outside the map, there is nothing to hit.
    if (y &lt; 0 || y &gt;= Constants.MAP_SIZE_Y ||
        x &lt; 0 || x &gt;= Constants.MAP_SIZE_X ||
        z &lt; 0 || z &gt;= Constants.MAP_SIZE_Z)
    {
        hit = false;
        return;
    }
    
    // Determine the index of the current working chunk in the Map by
    // bit-shifting the map-relative block coordinates
    int chunkIndexX = x &gt;&gt; 5;
    int chunkIndexY = y &gt;&gt; 5;
    int chunkIndexZ = z &gt;&gt; 5;

    // Get a reference to the current working chunk
    var c = chunks[chunkIndexX, chunkIndexY, chunkIndexZ];

    // Determine the chunk-relative position of the ray with a bit-mask
    int i = x &amp; 0x1f;
    int j = y &amp; 0x1f;
    int k = z &amp; 0x1f;

    // Calculate the access position of this block in the Chunk's data[] array
    int access = j + i * Constants.CHUNK_SIZE + k * Constants.CHUNK_SIZE_SQUARED;

    // Calculate the end position of the ray
    var end = start + velocity;

    // If the start and end positions of the ray both lie on the same coordinate on the voxel grid
    if (x == (int)end.X &amp;&amp; y == (int)end.Y &amp;&amp; z == (int)end.Z)
    {
        // The chunk is null if it contains no blocks
        if (c == null)
        {
            hit = false;
        }

        // If the block is empty
        else if (c.data[access].kind == 0)
        {
            hit = false;
        }

        // Else the ray begins and ends within the same non-empty block
        else
        {
            hit = true;
        }
        
        return;
    }
    
    ...
}
</code></pre>
<!--kg-card-end: markdown--><p></p><p>After this stage we can confirm that the ray will start and end at different voxel coordinates and therefore a ray march is required. To improve ray marching efficiency, we pre-calculate the following variables:</p><!--kg-card-begin: markdown--><pre><code class="language-csharp">// These variables are used to determine whether the ray has left the current working chunk.
//  For example when travelling in the negative Y direction,
//  if j == -1 then we have left the current working chunk
int iComparison, jComparison, kComparison;

// When leaving the current working chunk, the chunk-relative position must be reset.
//  For example when travelling in the negative Y direction,
//  j should be reset to CHUNK_SIZE - 1 when entering the new current working chunk
int iReset, jReset, kReset;

// When leaving the current working chunk, the access variable must also be updated.
//  These values store how much to add or subtract from the access, depending on
//  the direction of the ray:
int xAccessReset, yAccessReset, zAccessReset;

// The amount to increase i, j and k in each axis (either 1 or -1)
int iStep, jStep, kStep;

// When incrementing j, the chunk access is simply increased by 1
// When incrementing i, the chunk access is increased by 32 (CHUNK_SIZE)
// When incrementing k, the chunk access is increased by 1024 (CHUNK_SIZE_SQUARED)
// These variables store whether to increase or decrease by the above amounts
int xAccessIncrement, zAccessIncrement;

// The distance to the closest voxel boundary in map units
double xDist, yDist, zDist;

if (velocity.Y &gt; 0)
{
    jStep = 1;
    jComparison = Constants.CHUNK_SIZE;
    jReset = 0;
    yAccessReset = -Constants.CHUNK_SIZE;
    yDist = (y - start.Y + 1);
}
else
{
    jStep = -1;
    jComparison = -1;
    jReset = Constants.CHUNK_SIZE - 1;
    yAccessReset = Constants.CHUNK_SIZE;
    yDist = (start.Y - y);
}

// Same for velocity.X and velocity.Z
...

// This variable stores the current progress throughout the ray march
double t = 0.0;

velocity.Normalize();
double xInverted = Math.Abs(1 / velocity.X);
double yInverted = Math.Abs(1 / velocity.Y);
double zInverted = Math.Abs(1 / velocity.Z);

// Determine the distance to the closest voxel boundary in units of t
//  - These values indicate how far we have to travel along the ray to reach the next voxel
//  - If any component of the direction is perpendicular to an axis, the distance is double.PositiveInfinity
double xDistance = velocity.X == 0 ? double.PositiveInfinity : xInverted * xDist;
double yDistance = velocity.Y == 0 ? double.PositiveInfinity : yInverted * yDist;
double zDistance = velocity.Z == 0 ? double.PositiveInfinity : zInverted * zDist;</code></pre>
<!--kg-card-end: markdown--><p></p><p>The algorithm then runs in a loop until either:</p><ul><li><code>t</code> has reached the <code>max</code> length of the ray</li><li>a non-empty block is found</li><li>the ray exits the map</li></ul><!--kg-card-begin: markdown--><pre><code class="language-csharp">while (t &lt;= max)
{
    // Exit when we find a non-empty block
    if (c != null &amp;&amp; c.data[access].kind != 0)
    {
        hit = true;
        return;
    }
    
    // Determine the closest voxel boundary
    if (yDistance &lt; xDistance)
    {
        if (yDistance &lt; zDistance)
        {
            // Advance to the closest voxel boundary in the Y direction
            
            // Increment the chunk-relative position and the block access position
            j += jStep;
            access += jStep;

            // Check if we have exited the current working chunk.
            // This means that j is either -1 or 32
            if (j == jComparison)
            {
                // If moving in the positive direction, reset j to 0.
                // If moving in the negative Y direction, reset j to 31
                j = jReset;
                
                // Reset the chunk access
                access += yAccessReset;

                // Calculate the new chunk index
                chunkIndexY += jStep;

                // If the new chunk is outside the map, exit
                if (chunkIndexY &lt; 0 || chunkIndexY &gt;= Constants.CHUNK_AMOUNT_Y)
                {
                    hit = false;
                    return;
                }

                // Get a reference to the new working chunk
                c = chunks[chunkIndexX, chunkIndexY, chunkIndexZ];
            }

            // Update our progress in the ray 
            t = yDistance;
            
            // Set the new distance to the next voxel Y boundary
            yDistance += yInverted;
            
            // For collision purposes we also store the last axis that the ray collided with
            // This allows us to reflect particle velocity on the correct axis
            axis = Axis.Y;
        }
        else
        {
            // Advance to the closest voxel boundary in the Z direction
            ...
        }
    }
    else if (xDistance &lt; zDistance)
    {
        // Advance to the closest voxel boundary in the X direction
        ...
    }
    else
    {    
        // Advance to the closest voxel boundary in the Z direction
        ...
    }
}</code></pre>
<!--kg-card-end: markdown--><p></p><h2 id="benchmarks">Benchmarks</h2><p>The following benchmarks were run on a Ryzen 5 1600 CPU.</p><p>The average particle collision ray march in Sector's Edge travels 1-10 blocks and takes 250 nanoseconds to run. At 60 frames per second, this allows for 64000 rays per frame per thread.</p><p>For stress testing, 100,000 rays were cast in random directions across the map. The average ray length was 200-400 blocks and takes 3400 nanoseconds to run. At 60 frames per second, this allows for 4700 rays per frame per thread.</p><h2 id="in-practice">In Practice</h2><p>The full source code for this article is available <a href="https://github.com/Vercidium/voxel-ray-marching">here on GitHub</a>.</p><p>In Sector's Edge, ray marching is required for particle collisions and hit detection between projectiles and the map. See it in action in our latest video below:</p><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/qoKzhIouzsk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure>
    </section>


</article>
</main>

    <section class="footer-cta outer">
        <div class="inner">
            <h2 class="footer-cta-title">Sign up for more like this.</h2>
            <a class="footer-cta-button" href="#/portal" data-portal>
                <div class="footer-cta-input">Enter your email</div>
                <span>Subscribe</span>
            </a>
        </div>
    </section>



            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/sectors-edge-game-engine/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Sector&#x27;s Edge Game Engine
                </h2>
            </header>
                <div class="post-card-excerpt">During the past year I've made exciting advancements with raytraced audio, rendering systems, unsynchronised multithreading and much more.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-05-25">May 25, 2022</time>
                <span class="sep">—</span>
                <span class="post-card-meta-length">2 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="/blog/sectors-edge-allegiance-ux/">

        <img class="post-card-image"
            srcset="/blog/content/images/size/w300/2021/12/allegiance8WallpaperNoText.png 300w,
                    /blog/content/images/size/w600/2021/12/allegiance8WallpaperNoText.png 600w,
                    /blog/content/images/size/w1000/2021/12/allegiance8WallpaperNoText.png 1000w,
                    /blog/content/images/size/w2000/2021/12/allegiance8WallpaperNoText.png 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/blog/content/images/size/w600/2021/12/allegiance8WallpaperNoText.png"
            alt="Sector&#x27;s Edge - Allegiance + UX"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/sectors-edge-allegiance-ux/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Sector&#x27;s Edge - Allegiance + UX
                </h2>
            </header>
                <div class="post-card-excerpt">Rocket and I have spent the past month improving the tedious, unintuitive parts of the Sector's Edge UI and exploring a new compelling, rewarding and unique progression system.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2021-12-25">Dec 25, 2021</time>
                <span class="sep">—</span>
                <span class="post-card-meta-length">10 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="/blog/battlefield-2042-portal-creating-a-zombies-game-mode/">

        <img class="post-card-image"
            srcset="/blog/content/images/size/w300/2021/11/header2.jpg 300w,
                    /blog/content/images/size/w600/2021/11/header2.jpg 600w,
                    /blog/content/images/size/w1000/2021/11/header2.jpg 1000w,
                    /blog/content/images/size/w2000/2021/11/header2.jpg 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/blog/content/images/size/w600/2021/11/header2.jpg"
            alt="Battlefield 2042 Portal - Creating a Zombies Game Mode"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/blog/battlefield-2042-portal-creating-a-zombies-game-mode/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Battlefield 2042 Portal - Creating a Zombies Game Mode
                </h2>
            </header>
                <div class="post-card-excerpt">This guide explains how to create a Zombies game mode using the Battlefield 2042 Portal Rules Editor.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2021-11-15">Nov 15, 2021</time>
                <span class="sep">—</span>
                <span class="post-card-meta-length">6 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://vercidium.com/blog">Vercidium Blog</a> &copy; 2024</section>
            <nav class="site-footer-nav">
                <ul class="nav">
    <li class="nav-data-privacy"><a href="https://vercidium.com/blog/privacy/">Data &amp; privacy</a></li>
</ul>

            </nav>
            <div><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>


<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="/blog/assets/built/casper.js?v=2ad5fe5275"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/prism.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/components/prism-csharp.min.js"></script>

</body>
</html>
