Вот пример вычислительного шейдера на HLSL для заполнения 3D текстуры. Этот шейдер заполняет текстуру цветовым градиентом, зависящим от позиции вокселя:

```hlsl
// Определяем размеры группы потоков
[numthreads(8, 8, 8)]
void CSMain(
    uint3 globalID : SV_DispatchThreadID,
    uint3 localID : SV_GroupThreadID,
    uint3 groupID : SV_GroupID
)
{
    // Объявляем UAV для 3D текстуры
    RWTexture3D<float4> outputTexture : register(u0);

    // Получаем размеры текстуры
    uint3 textureDims;
    outputTexture.GetDimensions(textureDims.x, textureDims.y, textureDims.z);

    // Проверяем выход за границы текстуры
    if (globalID.x >= textureDims.x || 
        globalID.y >= textureDims.y || 
        globalID.z >= textureDims.z)
    {
        return;
    }

    // Нормализуем координаты (приводим к диапазону [0, 1])
    float3 normalizedCoords = float3(globalID) / float3(textureDims);

    // Вычисляем цвет вокселя
    float4 color;
    
    // Пример 1: Простой градиент
    color.r = normalizedCoords.x;          // Красный канал по X
    color.g = normalizedCoords.y;          // Зеленый канал по Y
    color.b = normalizedCoords.z;          // Синий канал по Z
    color.a = 1.0;                         // Альфа-канал

    // Пример 2: Сферический паттерн
    // float3 center = float3(0.5, 0.5, 0.5);
    // float distance = length(normalizedCoords - center);
    // color = float4(sin(distance * 20.0), cos(distance * 15.0), 1.0 - distance, 1.0);

    // Записываем результат в текстуру
    outputTexture[globalID] = color;
}
```

Для использования этого шейдера необходимо:

1. Создать 3D текстуру в приложении с флагом `UnorderedAccess`
2. Привязать текстуру к UAV (Unordered Access View)
3. Вызвать Dispatch с правильными размерами групп:
   ```cpp
   // Пример для текстуры 64x64x64
   deviceContext->Dispatch(8, 8, 8); // 64/8 = 8 по каждой оси
   ```

Ключевые элементы шейдера:
- `numthreads` определяет размеры группы потоков
- `SV_DispatchThreadID` - глобальные координаты вокселя
- `RWTexture3D` - UAV для записи в 3D текстуру
- Нормализация координат для работы в диапазоне [0, 1]
- Примеры вычисления цвета (можно модифицировать под свои нужды)

Для более сложных паттернов можно добавить:
- Шумовые функции
- Расстояния до геометрических фигур
- Анимации через параметры
- Генерацию procedural-текстур

Не забудьте проверить соответствие размеров текстур и параметров диспетчеризации в вашем приложении.