// More information on ULON format - https://developer.unigine.com/docs/code/formats/ulon_format
// More information on scriptable materials - https://developer.unigine.com/docs/content/materials/scriptable
BaseMaterial <preview_hidden=1 var_prefix=var texture_prefix=tex>
{
	Texture2D screen_texture <source=procedural internal=true>
	
	Color my_color = [0.5 0.5 0.5 1.0]

	Int max_steps = 100
	Float max_dist = 100.0
	Float surface_dist = 0.01
	Float sphere_radius = 1.0
	
	Pass my_pass
	{
		Fragment =
		#{
			#include <core/materials/shaders/render/common.h>

			INIT_STRUCTURED_BUFFER(0, float4, positions);

			STRUCT_FRAG_BEGIN
				INIT_COLOR(float4)
			STRUCT_FRAG_END
			
			float sdfSphere(float3 currentPos, float3 spherePos, float radius)
			{
				return length(spherePos - currentPos) - radius;
			}

			float3 sdfSphereNormal(float3 surfacePos, float3 spherePos)
			{
				return normalize(surfacePos - spherePos);
			}

			float4 getRayIntersectionSdfPoint(const float2 uv)
			{
				uint positionsNum;
				uint positionsStride;
				positions.GetDimensions(positionsNum, positionsStride);
				
				const float3 viewDirection = screenUVToViewDirection(uv);

				float currentDistance = var_surface_dist;
				for (int step = 0; step < var_max_steps; ++step)
				{
					const float3 currentPos = viewDirection * currentDistance;
					float currentMinDist = FLT_MAX;
					for (uint posIndex = 0; posIndex < positionsNum; ++posIndex)
					{
						const float3 spherePos = positions[posIndex].xyz;
						const float dist = sdfSphere(currentPos, spherePos, var_sphere_radius);
						currentMinDist = min(dist, currentMinDist);

						if (currentMinDist < var_surface_dist)
						{
							const float3 sdfNormal = sdfSphereNormal(currentPos, spherePos);
							const float3 lightVector = normalize(-currentPos);
							const float lightV = max(0.0, dot(sdfNormal, lightVector));
							return float4(float3(lightV, lightV, lightV), currentDistance);
						}
					}

					currentDistance += currentMinDist;
					if (currentDistance > var_max_dist)
						break;
				}

				return float4(0,0,0, -1.0f);
			}
			
			MAIN_FRAG_BEGIN(FRAGMENT_IN)
				const float4 color = TEXTURE_BIAS_ZERO(tex_screen_texture, IN_UV);
				
				const float4 sdfValue = getRayIntersectionSdfPoint(IN_UV);

				OUT_COLOR = sdfValue.w >=0.0f ? (var_my_color * float4(sdfValue.xyz, 1)) : color;
			MAIN_FRAG_END
		#}
	}
}

