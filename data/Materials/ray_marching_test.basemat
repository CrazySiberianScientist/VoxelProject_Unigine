// More information on ULON format - https://developer.unigine.com/docs/code/formats/ulon_format
// More information on scriptable materials - https://developer.unigine.com/docs/content/materials/scriptable
BaseMaterial <preview_hidden=1 var_prefix=var texture_prefix=tex>
{
	Texture2D depth_texture <source=procedural internal=true>
	Texture2D color_texture <source=procedural internal=true>
	Texture2D screen_depth_texture <source=procedural internal=true>
	
	Color my_color = [0.5 0.5 0.5 1.0]

	Int max_steps = 100
	Float max_dist = 100.0
	Float surface_dist = 0.001
	Float sphere_radius = 1.0
	
	Pass depth
	{
		Fragment =
		#{
			#include <core/materials/shaders/render/common.h>

			INIT_STRUCTURED_BUFFER(0, float4, positions);

			STRUCT_FRAG_BEGIN
				//INIT_COLOR(float)
				//INIT_CUSTOM_DEPTH(float)
				INIT_MRT(float3, 1)
			STRUCT_FRAG_END

			// https://www.shadertoy.com/view/Ml3Gz8
			// Polynomial smooth min (commented version)
			// @input a: first value
			// @input b: second value
			// @float k: 'Smoothness value', usually in the range (0,1].
			//           Values close to zero makes smin converge to min.
			//           Warning: the function is NOT defined at k = 0!
			//           Tip: negative values turn the funtion into smooth max!
			float smin(float a, float b, float k)
			{
			
			    // Compute the difference between the two values.
			    // This is used to interpolate both values inside the range (-k, k).
			    // Smaller ranges give a better approximation of the min function.
			    float h = a - b;

			    // The interval [-k, k] is mapped to [0, 1],
			    // and clamping takes place only after this transformation.

			    // Map [-k, k] to [0, 1] and clamp if outside the latter.
			    h = clamp(0.5 + 0.5*h/k, 0.0, 1.0);    

			    // Linearly interpolate the input values using h inside (0, 1).
			    // The second term ensures continuous derivatives at the boundaries of [0,1],
			    // but this is not completely obvious! See my blog post for details.
			    return lerp(a, b, h) - k*h*(1.0-h);
			}

			float sdfSphere(float3 currentPos, float3 objectPos, float radius)
			{
				return length(objectPos - currentPos) - radius;
			}

			float sdfBox0(float3 p, float3 b)
			{
				float3 q = abs(p) - b;
				return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
			}

			float sdfBox(const float3 currentPos, const  float3 objectPos, const  float3 size)
			{
				const float4x4 worldTransform = matrix4Col(float3(1,0,0), float3(0,1,0), float3(0,0,1));
				float4x4 viewTransform = mul(worldTransform, s_modelview);
				colW(viewTransform, objectPos);

				const float3 currentLocalPos = mul(inverse(viewTransform), float4(currentPos, 1));

				float3 delta = abs(currentLocalPos) - size;
				return length(max(delta,0.0)) + min(max(delta.x,max(delta.y,delta.z)),0.0);
			}

			float3 getRayIntersectionSdfPoint(const float2 uv)
			{
				uint positionsNum;
				uint positionsStride;
				positions.GetDimensions(positionsNum, positionsStride);
				
				const float3 viewDirection = normalize(screenUVToViewDirection(uv));

				float currentDistance = 0;

				const float viewDirectionL = length(viewDirection);

				for (int step = 0; step < var_max_steps; ++step)
				{
					const float3 currentPos = viewDirection * currentDistance  /*/ (viewDirectionL)*/;
					float currentMinDist = FLT_MAX;
					for (uint posIndex = 0; posIndex < positionsNum; ++posIndex)
					{
						const float3 spherePos = positions[posIndex].xyz;
						const float dist = sdfSphere(currentPos, spherePos, var_sphere_radius);
						//const float dist = sdfBox(currentPos, spherePos, float3(1,1,1));
						//currentMinDist = min(dist, currentMinDist);
						currentMinDist = smin(dist, currentMinDist, 1.0f);

						if (currentMinDist < var_surface_dist)
						{
							return float3(currentPos.xy, -currentPos.z);
						}
					}

					currentDistance += currentMinDist;
					if (currentDistance > var_max_dist)
						break;
				}

				return float3(FLT_MAX, FLT_MAX, FLT_MAX);
			}
			
			MAIN_FRAG_BEGIN(FRAGMENT_IN)
				OUT_MRT(1) = getRayIntersectionSdfPoint(IN_UV);
			MAIN_FRAG_END
		#}
	}

	Pass color
	{
		Fragment =
		#{
			#include <core/materials/shaders/render/common.h>

			STRUCT_FRAG_BEGIN
				INIT_COLOR(float4)
			STRUCT_FRAG_END

			

			float3 calcNormalByDepth(const float2 uv)
			{
				const float uv_dx = s_viewport.z;
				const float uv_dy = s_viewport.w;

				float3 pos0 = TEXTURE_BIAS_ZERO(tex_depth_texture, uv).xyz;
				float3 pos1 = TEXTURE_BIAS_ZERO(tex_depth_texture, uv + float2(uv_dx, 0)).xyz;
				float3 pos2 = TEXTURE_BIAS_ZERO(tex_depth_texture, uv + float2(0, uv_dy)).xyz;
				float3 pos3 = TEXTURE_BIAS_ZERO(tex_depth_texture, uv + float2(uv_dx, uv_dy)).xyz;
				//float3 normal = normalize(cross(pos1 - pos0, pos2 - pos0)) * 1000;
				float3 normal = sqrt(pow2(pos3 - pos0) + pow2(pos2 - pos0) + pow2(pos1 - pos0));

				return normal;
			}

			MAIN_FRAG_BEGIN(FRAGMENT_IN)
				const float4 color = TEXTURE_BIAS_ZERO(tex_color_texture, IN_UV);
				const float4 depth = TEXTURE_BIAS_ZERO(tex_depth_texture, IN_UV);
				//const float4 screen_depth = float4(nativeDepthToLinearDepth(TEXTURE_BIAS_ZERO(tex_depth_texture, IN_UV).r, IN_UV), 0, 0, 1);
				const float screen_depth = -nativeDepthToPositionVS(TEXTURE_BIAS_ZERO(tex_screen_depth_texture, IN_UV).r, IN_UV).z;

				bool isOverlap = depth.z < screen_depth;
				OUT_COLOR = color * !isOverlap + var_my_color * isOverlap;
				OUT_COLOR = float4(sqrt(abs(calcNormalByDepth(IN_UV))) , 1);
				//OUT_COLOR = float4(IN_UV, 0, 1);
			MAIN_FRAG_END
		#}
	}
}

