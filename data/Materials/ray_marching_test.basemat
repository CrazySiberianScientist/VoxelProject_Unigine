// More information on ULON format - https://developer.unigine.com/docs/code/formats/ulon_format
// More information on scriptable materials - https://developer.unigine.com/docs/content/materials/scriptable
BaseMaterial <preview_hidden=1 var_prefix=var texture_prefix=tex>
{
	Texture2D screen_texture <source=procedural internal=true>
	
	Color my_color = [0.5 0.5 0.5 1.0]

	Int max_steps = 100
	Float max_dist = 100.0
	Float surface_dist = 0.01
	Float sphere_radius = 1.0
	
	Pass my_pass
	{
		Fragment =
		#{
			#include <core/materials/shaders/render/common.h>

			INIT_STRUCTURED_BUFFER(0, float4, positions);

			STRUCT_FRAG_BEGIN
				INIT_COLOR(float4)
			STRUCT_FRAG_END
			
			// https://www.shadertoy.com/view/Ml3Gz8
			// Polynomial smooth min (commented version)
			// @input a: first value
			// @input b: second value
			// @float k: 'Smoothness value', usually in the range (0,1].
			//           Values close to zero makes smin converge to min.
			//           Warning: the function is NOT defined at k = 0!
			//           Tip: negative values turn the funtion into smooth max!
			float smin(float a, float b, float k) {
			
			    // Compute the difference between the two values.
			    // This is used to interpolate both values inside the range (-k, k).
			    // Smaller ranges give a better approximation of the min function.
			    float h = a - b;

			    // The interval [-k, k] is mapped to [0, 1],
			    // and clamping takes place only after this transformation.

			    // Map [-k, k] to [0, 1] and clamp if outside the latter.
			    h = clamp(0.5 + 0.5*h/k, 0.0, 1.0);    

			    // Linearly interpolate the input values using h inside (0, 1).
			    // The second term ensures continuous derivatives at the boundaries of [0,1],
			    // but this is not completely obvious! See my blog post for details.
			    return lerp(a, b, h) - k*h*(1.0-h);    
			}

			float sdfSphere(float3 currentPos, float3 spherePos, float radius)
			{
				return length(spherePos - currentPos) - radius;
			}

			float3 sdfSphereNormal(float3 surfacePos, float3 spherePos)
			{
				return normalize(surfacePos - spherePos);
			}

			float4 getRayIntersectionSdfPoint(const float2 uv)
			{
				uint positionsNum;
				uint positionsStride;
				positions.GetDimensions(positionsNum, positionsStride);
				
				const float3 viewDirection = screenUVToViewDirection(uv);

				float currentDistance = var_surface_dist;
				for (int step = 0; step < var_max_steps; ++step)
				{
					const float3 currentPos = viewDirection * currentDistance;
					float currentMinDist = FLT_MAX;
					for (uint posIndex = 0; posIndex < positionsNum; ++posIndex)
					{
						const float3 spherePos = positions[posIndex].xyz;
						const float dist = sdfSphere(currentPos, spherePos, var_sphere_radius);
						//currentMinDist = min(dist, currentMinDist);
						currentMinDist = smin(dist, currentMinDist, 2.0f);

						if (currentMinDist < var_surface_dist)
						{
							const float3 sdfNormal = sdfSphereNormal(currentPos, spherePos);
							const float3 lightVector = normalize(-currentPos);
							const float lightV = max(0.0, dot(sdfNormal, lightVector));
							return float4(float3(lightV, lightV, lightV), currentDistance);
						}
					}

					currentDistance += currentMinDist;
					if (currentDistance > var_max_dist)
						break;
				}

				return float4(0,0,0, -1.0f);
			}
			
			MAIN_FRAG_BEGIN(FRAGMENT_IN)
				const float4 color = TEXTURE_BIAS_ZERO(tex_screen_texture, IN_UV);
				
				const float4 sdfValue = getRayIntersectionSdfPoint(IN_UV);

				OUT_COLOR = sdfValue.w >=0.0f ? (var_my_color * float4(sdfValue.xyz, 1)) : color;
			MAIN_FRAG_END
		#}
	}
}

